#!/bin/bash

# Note taking app writen in bash modeled after jrnl[0].
# [0]: http://maebert.github.io/jrnl/

DATE=$(date +'%F %T')
NOTESFILE="$HOME/notes.txt"
SEPERATOR="---"
AWKRS="$SEPERATOR\n"

if [[ -z $EDITOR ]]; then EDITOR="vim"; fi
if [[ ! -e $NOTESFILE ]]; then touch $NOTESFILE; fi

prepend () {
	# A tempfile path used for prepending to file
	PREPENDTEMP='/tmp/outnotes'
	cat $1 $NOTESFILE > $PREPENDTEMP && mv $PREPENDTEMP $NOTESFILE
}
get_patterns () {
	OPERATOR=$1; shift
	PATTERNS=("$@")
	echo ${PATTERNS[@]} | sed -e "s/[[:space:]]/ $OPERATOR /g"
}
insert_seperator () { printf "%b\n" "$SEPERATOR" >> $1 ; }
check_modified () { if [[ $1 == $(stat -c %y "$2") ]]; then exit 1; fi ; }
get_entries () { awk '{s=tolower($0)}'" $1 "'{print $0 }' RS="$AWKRS" $NOTESFILE ; }
get_title () { printf "$1" | cut -f1 -d$'\n' ; }
delete_note () { sed -i~ -e "/$1/,/$SEPERATOR/d" $NOTESFILE ; }

# if no arguments then open editor and save the note.
if [[ $# == 0 ]]; then
	TEMP=$(mktemp); printf "%s " "$DATE" > $TEMP
	TEMPMODIFIED=$(stat -c %y "$TEMP")
	$EDITOR $TEMP
	check_modified "$TEMPMODIFIED" "$TEMP"
	insert_seperator $TEMP
	prepend $TEMP

# if content is given as arguments than parse it and save it as an note.
elif [[ $1 =~ ^[[:alnum:]] ]]; then
	CONTENT="$(echo $* | sed -e $'s/\. /\.\\n/')"
	printf "%s %s\n%b\n" "$DATE" "$CONTENT" $SEPERATOR | prepend -

else
	PATTERNS=()
	PATTERNOPERATOR="||"
	while [[ $# > 0 ]]; do
		case $1 in
			@* )
				READ=true
				TAG=${1,,}
				PATTERNS+=("s~/${TAG}/")
				shift
				;;
			-r|--read )
				READ=true
				shift
				;;
			-e|--edit )
				EDIT=true
				shift
				SEARCH="$@"
				break
				;;
			-d|--d )
				DELETE=true
				shift
				SEARCH="$@"
				break
				;;
			-ls|--list )
				LIST=true
				shift
				;;
			--and )
				PATTERNOPERATOR="\&\&"
				shift
				;;
			* )
				shift
				;;
		esac
	done

	if [[ $SEARCH ]]; then
		MATCHES=$(grep -i -o "$SEARCH" $NOTESFILE | wc -l)

		if [[ $MATCHES && $MATCHES > 1 ]]; then
			awk '{s=tolower($0)}'" s~/$SEARCH/ "'{ print $1, $2 }' \
				RS="$AWKRS" FS="\n" $NOTESFILE

		elif [[ $MATCHES == '0' ]]; then
			echo "No notes found"

		elif [[ $MATCHES == "1" ]]; then

			if [[ $DELETE ]]; then
				NOTE=$(get_entries "s~/$SEARCH/")
				printf "\n%s\n\n" "$NOTE"
				read -p "Delete the above note, y/n? " -n 1 -r
				echo
				if [[ $REPLY =~ ^[Yy]$ ]]; then
					delete_note "$(get_title "$NOTE")"
				fi

			elif [[ $EDIT ]]; then
				OLDNOTE=$(get_entries "s~/$SEARCH/")
				NEWNOTE=$(printf "$1" | \
					sed -e "s/^[0-9\-]\{10\} [0-9:]\{8\}/$DATE/g")
				TEMP=$(mktemp); printf "$NOTE" > "$TEMP"
				TEMPMODIFIED=$(stat -c %y "$TEMP")
				$EDITOR $TEMP
				check_modified "$TEMPMODIFIED" "$TEMP"
				insert_seperator $TEMP
				prepend $TEMP
				delete_note "$(get_title "$OLDNOTE")"
			fi
		fi

	elif [[ $LIST ]]; then
		PATTERN="$(get_patterns $PATTERNOPERATOR "${PATTERNS[@]}")"
		awk '{s=tolower($0)}'" $PATTERN "'{
			printf "%s ", $1
			split($0, words, " ")
			for (i in words)
				if (words[i] ~ "@.*")
					printf "%s ", words[i]
			printf "\n"
		}' RS="$AWKRS" FS="\n" $NOTESFILE

	elif [[ $READ ]]; then
		get_entries "$(get_patterns $PATTERNOPERATOR "${PATTERNS[@]}")"
	fi
fi

if [[ -e $TEMP ]]; then rm $TEMP; fi
