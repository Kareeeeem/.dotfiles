#!/bin/bash

# TODO return propert feedback in case of errors. write a good usage message

# Get the current datetime in human readable format.
DATE=$(date +'%F %T')
# mawk does not support intervals in regex
DATEREGEX="[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]"
NOTESFILE="$HOME/.notes.txt"
BACKUPFILE="$NOTESFILE~"
SEPERATOR="---"
AWKRS="$SEPERATOR\n"
BACKUPFILE="$NOTESFILE~"

ADDEDMSG="Added entry to notes."
DELETEDMSG="Deleted entry/entries from notes."
EDITEDMSG="Deleted entry from notes."
NOMATCHESMSG="No notes found with that id."
UNDOMSG="Restored previous state."

if [[ -z $EDITOR ]]; then EDITOR="vim"; fi
if [[ ! -e $NOTESFILE ]]; then touch $NOTESFILE; fi

insert_seperator () { printf "%b\n" "$SEPERATOR" >> $1 ; }

# check if the given modified time differs from the actual modified time.
is_modified () { [[ $1 != $(stat -c %y "$2") ]]; }

# given a pattern print the full records seperated by the AWKRS string.
get_notes () { awk "$1"'{print $0 }' RS="$AWKRS" $NOTESFILE ; }

# return the next highest id The id is always the first field of every record.
get_next_id () { awk '{print ++$1}' $NOTESFILE | sort -nr | head -n1; }

# create a backup file, allows a single undo.
create_backup () { cp $NOTESFILE $BACKUPFILE ; }

# restore the backup and save the current one as backup.
restore_backup () {
	TEMPNOTE='/tmp/outnotes'
	cp $NOTESFILE $TEMPNOTE
	mv $BACKUPFILE $NOTESFILE
	mv $TEMPNOTE $BACKUPFILE
}

get_pattern () {
	# if the full algument string starts with a / then the pattern should
	# contain the whole string for a full text search.
	if [[ $* == /* ]]; then
		echo "/$(echo $* | cut -c 2-)/"
	# otherwise generate an array of patterns.
	else
		PATTERNS=(); LOGICALOPERATOR="||"
		while [[ $# > 0 ]]; do
			case $1 in
				@* ) PATTERNS+=('tolower($0)~'"/${1,,}/"); shift; ;;
				--and ) LOGICALOPERATOR="\&\&"; shift; ;;
				# Do nothing in any other case.
				# TODO Should return some proper feedback about usage.
				* ) ;;
			esac
		done
		# concat the array and insert the logical operator in between each tag.
		echo ${PATTERNS[@]} | sed -e "s/[[:space:]]/ $LOGICALOPERATOR /g"
	fi
}

list_notes () {
	awk 'BEGIN {printf "ID\tADDED\tTITLE\tTAGS\n"}'"$(get_pattern $@)"'{
		printf "%s\t", $1
		split($0, words, " ")
		for (i in words)
			if (words[i] ~ "@.*")
				printf "%s ", words[i]
		printf "\n"
	}' RS="$AWKRS" FS="\n" $NOTESFILE | \
		sed 's/\([0-9]*\) \([0-9-]*\) \([0-9:]*\) \(.*\)/\1\t\2 \3\t\4/' | \
		column -ts $'\t'
}

# remove a note from the file.
delete_note () {
	sed -i -e "/^$1 $DATEREGEX/,/$SEPERATOR/d" $NOTESFILE
}

# insert a note captured in a tempfile into the notesfile.
insert_note () {
	create_backup
	TEMPNOTE='/tmp/outnotes'
	insert_seperator $1
	cat $1 $NOTESFILE > $TEMPNOTE && mv $TEMPNOTE $NOTESFILE
}

# prompt the user to confirm the deletion
delete_prompt () {
	create_backup
	NOTE=$(get_notes "/^$1 $DATEREGEX/")
	printf "\n%s\n\n" "$NOTE"
	read -p "Delete the above note, y/n? " -n 1 -r; echo
	if [[ $REPLY =~ ^[Yy]$ ]]; then delete_note $1; fi
}

# pull the relevant note into a tempfile and present it to the user.
# update the timestamp and move the updated note up to the top of the file.
edit_note () {
	create_backup
	OLDNOTE=$(get_notes "/^$1 $DATEREGEX/")
	NEWNOTE=$(printf "$OLDNOTE" | \
		sed -e "s/\(^[0-9]*\) [0-9\-]\{10\} [0-9:]\{8\}/\1 $DATE/g")
	TEMP=$(mktemp); printf "$NEWNOTE" > "$TEMP"
	TEMPMODIFIED=$(stat -c %y "$TEMP")
	$EDITOR $TEMP
	if is_modified "$TEMPMODIFIED" "$TEMP"; then
		delete_note $1
		insert_note $TEMP
	fi
}

# List the first line of all notes. Insert tabs and line everything up nicely.
if [[ $# == 0 ]]; then
	TEMP=$(mktemp); printf "%s %s " $(get_next_id) "$DATE" > $TEMP
	TEMPMODIFIED=$(stat -c %y "$TEMP")
	$EDITOR $TEMP +'normal $'
	if is_modified "$TEMPMODIFIED" "$TEMP"; then
		insert_note $TEMP
		echo $ADDEDMSG
	fi

elif [[ $1 == del || $1 == edit ]]; then
	MATCHES=$(grep -i -o "^$2 $DATEREGEX" $NOTESFILE | wc -l)
	if [[ $MATCHES == "1" && $1 == del ]]; then
		delete_prompt $2
		echo $DELETEDMSG
	elif [[ $MATCHES == "1" && $1 == edit ]]; then
		edit_note $2
		echo $EDITEDMSG
	else
		echo $NOMATCHESMSG
	fi

elif [[ $1 == undo ]]; then restore_backup; echo $UNDOMSG

elif [[ $1 == ls ]]; then shift; list_notes "$@";

elif [[ $1 == read ]]; then shift; get_notes "$(get_pattern $@)"

# In any other case interpret the arguments as a note. Anything before a period
# is the title and anything after the content.
else
	CONTENT="$(echo $* | sed -e $'s/\. /\.\\n/')"
	TEMP=$(mktemp); printf "%s %s %s\n" \
		$(get_next_id) "$DATE" "$CONTENT" > $TEMP
	insert_note $TEMP
	echo $ADDEDMSG
fi

if [[ -e $TEMP ]]; then rm $TEMP; fi
