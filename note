#!/bin/bash

# TODO return propert feedback in case of errors. write a good usage message

DATE=$(date +'%F %T')
# mawk does not support intervals in regex
DATEREGEX="[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]"
NOTESFILE="$HOME/notes.txt"
SEPERATOR="---"
AWKRS="$SEPERATOR\n"

if [[ -z $EDITOR ]]; then EDITOR="vim"; fi
if [[ ! -e $NOTESFILE ]]; then touch $NOTESFILE; fi

insert_seperator () { printf "%b\n" "$SEPERATOR" >> $1 ; }

is_modified () { [[ $1 != $(stat -c %y "$2") ]]; }

get_entries () { awk "$1"'{print $0 }' RS="$AWKRS" $NOTESFILE ; }

get_next_id () { awk '{print ++$1}' $NOTESFILE | sort -nr | head -n1; }

delete_note () { sed -i~ -e "/^$1 $DATEREGEX/,/$SEPERATOR/d" $NOTESFILE ; }

insert_note () {
	TEMPNOTE='/tmp/outnotes'
	insert_seperator $1
	cat $1 $NOTESFILE > $TEMPNOTE && mv $TEMPNOTE $NOTESFILE
}

get_pattern () {
	PATTERNS=()
	LOGICALOPERATOR="||"
	while [[ $# > 0 ]]; do
		case $1 in
			@* ) PATTERNS+=('tolower($0)~'"/${1,,}/"); shift; ;;
			--and ) LOGICALOPERATOR="\&\&"; shift; ;;
		esac
	done
	echo ${PATTERNS[@]} | sed -e "s/[[:space:]]/ $LOGICALOPERATOR /g"
}

promp_to_delete_note () {
	NOTE=$(get_entries "/^$1 $DATEREGEX/")
	printf "\n%s\n\n" "$NOTE"
	read -p "Delete the above note, y/n? " -n 1 -r; echo
	if [[ $REPLY =~ ^[Yy]$ ]]; then delete_note $1; fi; }

edit_note () {
	OLDNOTE=$(get_entries "/^$1 $DATEREGEX/")
	NEWNOTE=$(printf "$OLDNOTE" | sed -e "s/\(^[0-9]*\) [0-9\-]\{10\} [0-9:]\{8\}/\1 $DATE/g")
	TEMP=$(mktemp); printf "$NEWNOTE" > "$TEMP"
	TEMPMODIFIED=$(stat -c %y "$TEMP")
	$EDITOR $TEMP
	if is_modified "$TEMPMODIFIED" "$TEMP"; then delete_note $1; insert_note $TEMP; fi
}

list_notes () {
	awk "$(get_pattern $@)"'{
		printf "%s ", $1
		split($0, words, " ")
		for (i in words)
			if (words[i] ~ "@.*")
				printf "%s ", words[i]
		printf "\n"
	}' RS="$AWKRS" FS="\n" $NOTESFILE
}

if [[ $# == 0 ]]; then
	TEMP=$(mktemp); printf "%s %s " $(get_next_id) "$DATE" > $TEMP
	TEMPMODIFIED=$(stat -c %y "$TEMP")
	$EDITOR $TEMP
	if is_modified "$TEMPMODIFIED" "$TEMP"; then insert_note $TEMP; fi;

elif [[ $1 == del || $1 == edit ]]; then
	MATCHES=$(grep -i -o "^$2 $DATEREGEX" $NOTESFILE | wc -l)
	if [[ $MATCHES == "1" && $1 == del ]]; then promp_to_delete_note $2
	elif [[ $MATCHES == "1" && $1 == edit ]]; then edit_note $2
	else echo "No notes found"
	fi

elif [[ $1 == ls ]]; then shift; list_notes "$@";
elif [[ $1 == read ]]; then shift; get_entries "$(get_pattern $@)"

else
	CONTENT="$(echo $* | sed -e $'s/\. /\.\\n/')"
	TEMP=$(mktemp); printf "%s %s %s\n" $(get_next_id) "$DATE" "$CONTENT" > $TEMP
	insert_note $TEMP
fi

if [[ -e $TEMP ]]; then rm $TEMP; fi
